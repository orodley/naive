translation_unit = list(ASTToplevel, external_decl)

external_decl = seq(build_toplevel, which(function_definition, decl))

function_definition =
	seq(build_function_definition, decl_specifiers, declarator,
		opt(list(ASTDecl, decl)), compound_statement)

build_function_definition =
	build(ASTFunctionDef, 4,
		specifiers, #0,
		declarator, #1,
		old_style_param_decls, #2,
		body, #3)

decl_specifiers =
	list(ASTDeclSpecifier,
		or(storage_class_specifier,
			type_specifier,
			type_qualifier,
			function_specifier))

decl =
	seq(build_decl, decl_specifiers, opt(init_declarator_list), TOK_SEMICOLON)

build_decl =
	build(ASTDecl, 3,
		decl_specifiers, #0,
		init_declarators, #1)

init_declarator_list = list(ASTInitDeclarator, init_declarator)

init_declarator =
	seq(build_init_declarator,
		declarator,
		opt(seq(second, TOK_ASSIGN, initializer)))

build_init_declarator =
	build(ASTInitDeclarator, 2,
		declarator, #0,
		initializer, #1)

storage_class_specifier =
	seq(build_storage_class_specifier,
		which(keyword(typedef), keyword(extern), keyword(static),
			keyword(auto), keyword(register)))

type_specifier =
	seq(build_type_specifier_decl_specifier,
		or(seq(build_named_type, named_type),
			struct_or_union_specifier,
			enum_specifier))

build_type_specifier_decl_specifier =
	build(ASTDeclSpecifier, 1,
		type, TYPE_SPECIFIER,
		val.type_specifier, #0)

build_named_type =
	build(ASTTypeSpecifier, 1,
		type, NAMED_TYPE_SPECIFIER,
		val.name, "((Token *)#0)->val.symbol_or_string_literal")

struct_or_union_specifier =
	or(seq(build_struct_or_union, struct_or_union, opt(TOK_SYMBOL),
			TOK_LCURLY, list(ASTFieldDecl, field_decl), TOK_RCURLY),
		seq(build_struct_or_union_tagged_named_type, struct_or_union, TOK_SYMBOL))

struct_or_union = which(keyword(struct), keyword(union))

field_decl =
	seq(build_field_decl, decl_specifiers,
		field_declarator_list, TOK_SEMICOLON)

build_field_decl =
	build(ASTFieldDecl, 3,
		decl_specifiers, #0,
		field_declarators, #1)

field_declarator_list = list(ASTFieldDeclarator, field_declarator, TOK_COMMA)

field_declarator =
	or(seq(build_bitfield_declarator, opt(declarator), TOK_COLON, expr),
		seq(build_field_declarator, declarator))

build_bitfield_declarator =
	build(ASTFieldDeclarator, 3,
		type, BITFIELD_FIELD_DECLARATOR,
		val.bitfield.declarator, #0,
		val.bitfield.width, #2)

build_field_declarator =
	build(ASTFieldDeclarator, 1,
		type, NORMAL_FIELD_DECLARATOR,
		val.declarator, #0)

enum_specifier =
	or(seq(build_enum, keyword(enum), opt(TOK_SYMBOL), TOK_LCURLY,
			enumerator_list, opt(TOK_COMMA), TOK_RCURLY),
		seq(build_enum_tagged_named_type, keyword(enum), TOK_SYMBOL))

enumerator_list = list(ASTEnumerator, enumerator, TOK_COMMA)

enumerator =
	seq(build_enumerator, TOK_SYMBOL, opt(seq(second, TOK_ASSIGN, expr)))

build_enumerator =
	build(ASTEnumerator, 2,
		name, "((Token *)#0)->val.symbol_or_string_literal",
		value, #1)

type_qualifier =
	seq(build_type_qualifier,
		which(keyword(const), keyword(restrict), keyword(volatile)))

function_specifier = seq(build_function_specifier, keyword(inline))

declarator =
	or(seq(build_pointee_declarator, opt(pointer), direct_declarator),
		seq(build_terminal_pointer, pointer))

pointer =
	fold(build_next_pointer,
		seq(build_initial_pointer_result, single_pointer),
		single_pointer)

single_pointer =
	seq(build_pointer, TOK_ASTERISK, opt(list(ASTDeclSpecifier, type_qualifier)))

build_initial_pointer_result =
	build(PointerResult, 1, first, #0, last, #0)

build_pointer =
	build(ASTDeclarator, 2,
		type, POINTER_DECLARATOR,
		val.pointer_declarator.decl_specifiers, #1,
		val.pointer_declarator.pointee, NULL)

direct_declarator =
	fold(build_sub_declarator,
		or(seq(build_ident_declarator, TOK_SYMBOL),
			seq(build_declarator, TOK_LROUND, declarator, TOK_RROUND)),
		which(seq(middle, TOK_LSQUARE, opt(expr), TOK_RSQUARE),
			seq(middle, TOK_LROUND, parameter_type_list, TOK_RROUND)))

build_ident_declarator =
	build(ASTDirectDeclarator, 1,
		type, IDENTIFIER_DECLARATOR,
		val.name, "((Token *)#0)->val.symbol_or_string_literal")

build_declarator =
	build(ASTDirectDeclarator, 3,
		type, DECLARATOR,
		val.declarator, #1)

parameter_type_list =
	seq(first,
		list(ASTParameterDecl, parameter_decl, TOK_COMMA),
		opt(seq(ignore, TOK_COMMA, TOK_ELLIPSIS)))

parameter_decl =
	seq(build_parameter_decl, decl_specifiers, declarator)

build_parameter_decl =
	build(ASTParameterDecl, 2,
		decl_specifiers, #0,
		declarator, #1)

type_name = seq(build_type_name, decl_specifiers, opt(declarator))

build_type_name =
	build(ASTTypeName, 2,
		decl_specifiers, #0,
		declarator, #1)

initializer =
	or(seq(build_expr_initializer, assignment_expr),
		seq(build_brace_initializer, TOK_LCURLY, initializer_list,
			opt(TOK_COMMA), TOK_RCURLY))

build_expr_initializer =
	build(ASTInitializer, 1,
		type, EXPR_INITIALIZER,
		val.expr, #0)

build_brace_initializer =
	build(ASTInitializer, 4,
		type, BRACE_INITIALIZER,
		val.initializer_elements, #1)

initializer_list = list(ASTInitializerElement, initializer_element, TOK_COMMA)

initializer_element =
	seq(build_initializer_element,
		opt(seq(first, designator_list, TOK_ASSIGN)),
		initializer)

build_initializer_element =
	build(ASTInitializerElement, 2,
		designators, #0,
		initializer, #1)

designator_list = list(ASTDesignator, designator)

designator =
	or(seq(build_index_designator, TOK_LSQUARE, expr, TOK_RSQUARE),
		seq(build_field_designator, TOK_DOT, TOK_SYMBOL))

build_index_designator =
	build(ASTDesignator, 3,
		type, INDEX_DESIGNATOR,
		val.index_expr, #1)

build_field_designator =
	build(ASTDesignator, 2,
		type, FIELD_DESIGNATOR,
		val.field_name, "((Token *)#1)->val.symbol_or_string_literal")


statement =
	or(labeled_statement,
		compound_statement,
		expr_statement,
		selection_statement,
		iteration_statement,
		jump_statement)

labeled_statement =
	or(seq(build_labeled_statement, identifier, TOK_COLON, statement),
		seq(build_case_statement,
			keyword(case), expr, TOK_COLON, statement),
		seq(build_labeled_statement, keyword(default), TOK_COLON, statement))

compound_statement =
	seq(build_compound_statement, TOK_LCURLY, block_item_list, TOK_RCURLY)

block_item_list =
	list(ASTBlockItem, seq(build_block_item, which(decl, statement)))

expr_statement = seq(build_expr_statement, opt(expr), TOK_SEMICOLON)

selection_statement =
	or(seq(build_if_statement, keyword(if), TOK_LROUND, expr, TOK_RROUND,
			statement, opt(seq(second, keyword(else), statement))),
		seq(build_switch_statement, keyword(switch),
			TOK_LROUND, expr, TOK_RROUND, statement))

iteration_statement =
	or(seq(build_while_statement,
			keyword(while), TOK_LROUND, expr, TOK_RROUND, statement),
		seq(build_do_while_statement, keyword(do), statement, keyword(while),
			TOK_LROUND, expr, TOK_RROUND, TOK_SEMICOLON),
		seq(build_for_statement, keyword(for), TOK_LROUND,
			opt(expr), TOK_SEMICOLON, opt(expr), TOK_SEMICOLON, opt(expr),
			TOK_RROUND, statement),
		seq(build_for_decl_statement, keyword(for), TOK_LROUND,
			decl, opt(expr), TOK_SEMICOLON, opt(expr),
			TOK_RROUND, statement))

jump_statement =
	or(seq(build_goto_statement, keyword(goto), identifier),
		seq(build_continue_statement, keyword(continue), TOK_SEMICOLON),
		seq(build_break_statement, keyword(break), TOK_SEMICOLON),
		seq(build_return_statement, keyword(return), opt(expr), TOK_SEMICOLON))



primary_expr =
    or(identifier,
        constant,
        seq(middle, TOK_LROUND, expr, TOK_RROUND))

constant =
	seq(build_constant,
		or(TOK_INT_LITERAL, TOK_FLOAT_LITERAL, TOK_STRING_LITERAL))

postfix_expr =
    or(fold(build_postfix_expr,
			primary_expr,
			which(seq(middle, TOK_LSQUARE, expr, TOK_RSQUARE),
				seq(middle, TOK_LROUND, argument_expr_list, TOK_RROUND),
				seq(second, TOK_DOT, identifier),
				seq(second, TOK_ARROW, identifier),
				TOK_INCREMENT,
				TOK_DECREMENT)),
        seq(build_compound_initializer,
			TOK_LROUND, type_name, TOK_RROUND, TOK_LCURLY,
            initializer_list, opt(TOK_COMMA),
            TOK_RCURLY))

identifier = seq(build_identifier, TOK_SYMBOL)

argument_expr_list = list(ASTArgument, seq(build_argument, assignment_expr), TOK_COMMA)

build_argument = build(ASTArgument, 1, expr, #0, next, NULL)


unary_expr =
    or(postfix_expr,
        seq(build_unary_expr, TOK_INCREMENT, unary_expr),
        seq(build_unary_expr, TOK_DECREMENT, unary_expr),
        seq(build_unary_expr, unary_operator, cast_expr),
        seq(build_sizeof_expr, keyword(sizeof), unary_expr),
        seq(build_sizeof_type, keyword(sizeof), TOK_LROUND, type_name, TOK_RROUND))

unary_operator =
    or(TOK_AMPERSAND, TOK_ASTERISK, TOK_PLUS, TOK_MINUS, TOK_BIT_NOT, TOK_LOGICAL_NOT)

cast_expr =
    or(unary_expr,
        seq(build_cast_expr, TOK_LROUND, type_name, TOK_RROUND, cast_expr))

multiplicative_expr =
    fold(build_binary_head,
		cast_expr,
		or(seq(build_binary_tail, TOK_ASTERISK, cast_expr),
			seq(build_binary_tail, TOK_DIVIDE, cast_expr),
			seq(build_binary_tail, TOK_MODULO, cast_expr)))

additive_expr =
    fold(build_binary_head,
		multiplicative_expr,
		or(seq(build_binary_tail, TOK_PLUS, multiplicative_expr),
			seq(build_binary_tail, TOK_MINUS, multiplicative_expr)))

shift_expr =
    fold(build_binary_head,
		additive_expr,
		or(seq(build_binary_tail, TOK_LEFT_SHIFT, additive_expr),
			seq(build_binary_tail, TOK_RIGHT_SHIFT, additive_expr)))

relational_expr =
    fold(build_binary_head,
		shift_expr,
		or(seq(build_binary_tail, TOK_LESS_THAN, shift_expr),
			seq(build_binary_tail, TOK_GREATER_THAN, shift_expr),
			seq(build_binary_tail, TOK_LESS_THAN_OR_EQUAL, shift_expr),
			seq(build_binary_tail, TOK_GREATER_THAN_OR_EQUAL, shift_expr)))

equality_expr =
    fold(build_binary_head,
		relational_expr,
        or(seq(build_binary_tail, TOK_EQUAL, relational_expr),
			seq(build_binary_tail, TOK_NOT_EQUAL, relational_expr)))

and_expr =
    fold(build_binary_head,
		equality_expr,
		seq(build_binary_tail, TOK_AMPERSAND, equality_expr))

xor_expr =
	fold(build_binary_head,
		and_expr,
		seq(build_binary_tail, TOK_BIT_XOR, and_expr))

or_expr =
	fold(build_binary_head,
		xor_expr,
		seq(build_binary_tail, TOK_BIT_OR, xor_expr))

logical_and_expr =
    fold(build_binary_head,
		or_expr,
		seq(build_binary_tail, TOK_LOGICAL_AND, or_expr))

logical_or_expr =
    fold(build_binary_head,
		logical_and_expr,
		seq(build_binary_tail, TOK_LOGICAL_OR, logical_and_expr))


conditional_expr =
    or(logical_or_expr,
        seq(build_conditional_expr,
			logical_or_expr, TOK_QUESTION_MARK,
            expr, TOK_COLON,
            conditional_expr))

assignment_expr =
    fold(build_binary_head,
		conditional_expr,
        seq(build_binary_tail, assignment_operator, assignment_expr))

assignment_operator =
    or(TOK_ASSIGN, TOK_MULT_ASSIGN, TOK_DIVIDE_ASSIGN, TOK_MODULO_ASSIGN,
		TOK_PLUS_ASSIGN, TOK_MINUS_ASSIGN, TOK_LEFT_SHIFT_ASSIGN,
		TOK_RIGHT_SHIFT_ASSIGN, TOK_BIT_AND_ASSIGN, TOK_BIT_XOR_ASSIGN,
		TOK_BIT_OR_ASSIGN)

expr =
    fold(build_binary_head,
		assignment_expr,
        seq(build_binary_tail, TOK_COMMA, assignment_expr))
